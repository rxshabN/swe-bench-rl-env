#!/usr/bin/env python3
"""
Grading runner for Transmission (C++) Agent Evaluation.
"""

import logging
import os
import subprocess
import sys
import threading
import uuid
from pathlib import Path
from .utils import merge_junits

logger = logging.getLogger(__name__)

class GradingRunner:
    """Handles the grading workflow for C++/Transmission."""

    def __init__(
        self,
        base: str,
        test: str,
        golden: str,
        # Keep these arguments for compatibility with the framework, even if unused
        playwright_test_files: list[str] | None = None,
        mocha_test_files: list[str] | None = None,
        test_files: list[str] | None = None,
        test_patch_path: str = "/home/ubuntu/test.patch",
        golden_patch_path: str = "/home/ubuntu/golden.patch",
        only_server: bool = False,
    ):
        self.use_base = base
        self.use_test = test
        self.use_golden = golden
        self.test_patch_path = test_patch_path
        self.golden_patch_path = golden_patch_path
        self.test_files = test_files or []
        self.grade_working_dir = "/tmp/grading_workspace_" + str(uuid.uuid4())
        
        # Repo path comes from the Dockerfile ENV
        self.original_repo_path = os.environ.get("REPO_PATH", "/home/ubuntu/repo")

    def _format_junit_xml(self, test_name: str, message: str, stdout: str, stderr: str) -> str:
        """Fallback to generate XML if the C++ build crashes completely."""
        return f"""<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="{test_name}" tests="1" failures="1" errors="0" skipped="0">
    <testcase classname="{test_name}" name="test{test_name}" time="0.0">
      <failure type="TestFailure">\n{message}\n</failure>
      <system-out>\n{stdout}\n</system-out>
      <system-err>\n{stderr}\n</system-err>
    </testcase>
  </testsuite>
</testsuites>"""

    def run_tests(self) -> str:
        """Run CTest and return JUnit XML output."""
        logger.info(f"Running CTest in {self.grade_working_dir}")
        
        build_dir = Path(self.grade_working_dir) / "build"
        
        # CTest command: Runs tests and outputs XML for scoring
        cmd = [
            "ctest",
            "--output-junit", "junit_results.xml",
            "--output-on-failure"
        ]

        # Execute inside the build directory
        result = subprocess.run(
            cmd,
            cwd=build_dir,
            capture_output=True,
            text=True,
        )
        
        logger.info(f"Tests completed with code: {result.returncode}")
        
        # Read the XML generated by CTest
        xml_path = build_dir / "junit_results.xml"
        if xml_path.exists():
            with open(xml_path) as f:
                return f.read()
        else:
            return self._format_junit_xml("CTestCrash", "CTest failed to generate XML", result.stdout, result.stderr)

    def _cleanup_generated_files(self):
        pass

    def run_grading(self) -> tuple[bool, dict]:
        """Run the complete C++ grading workflow."""
        logger.info("Starting grading workflow")

        # 1. Copy repo
        logger.info(f"Copying repo to {self.grade_working_dir}")
        subprocess.run(["cp", "-r", self.original_repo_path, self.grade_working_dir], check=True)

        # 2. Apply test patch (if exists)
        if os.path.exists(self.test_patch_path):
            logger.info("Applying test patch")
            with open(self.test_patch_path) as f:
                subprocess.run(["git", "apply"], check=True, cwd=self.grade_working_dir, input=f.read().encode("utf-8"))

        # 3. Build (Ninja)
        logger.info(f"Compiling in {self.grade_working_dir}")
        
        # We use Ninja because we pre-configured CMake in the Dockerfile
        build_process = subprocess.run(
            ["ninja"],
            cwd=str(Path(self.grade_working_dir) / "build"),
            capture_output=True,
            text=True
        )
        
        if build_process.returncode != 0:
            logger.info(f"Compilation failed: {build_process.stderr}")
            xml_content = self._format_junit_xml("CompileError", "Build Failed", build_process.stdout, build_process.stderr)
            return False, {"junit": xml_content}

        logger.info("Compilation successful.")

        # 4. Run Tests
        junit_xml = self.run_tests()
        
        # Check for success (0 failures in XML)
        is_success = 'failures="0"' in junit_xml and 'errors="0"' in junit_xml

        return is_success, {"junit": junit_xml}